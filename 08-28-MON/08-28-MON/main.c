//
//  main.c
//  08-28-MON
//
//  Created by 박지현 on 2023/08/28.
//

//#include <stdio.h>

//int main(void) {
    /*//a : 달팽이의 낮에 올라가는 높이
    //b : 밤에 미끄러지는 높이
    //v : 나무 막대 높이
    //d : 달팽이가 며칠 걸리는지 저장하는 변수
    int a,b,v,d;
    scanf("%d %d %d",&a,&b,&v);

    //달팽이가 나무 막대를 모두 올라가는데 걸리는 날짜를 계산하는 식
    //-1을 하는 이유 : 달팽이가 정상에 도달한 경우, 다음 날에는 미끄러지지 않기 때문
    //(v - b - 1) : 달팽이가 정상에 도달한 높이
    //(a - b) : 달팽이가 낮에 얼마나 올라갈 수 있는지 나타냄
    //(v - b - 1) / (a - b) : 달팽이가 정상에 도달하기 위해 필요한 일 수
    //+ 1 : 달팽이가 정상에 도달한 날짜를 계산
    d = (v - b - 1) / (a - b) +1;
    printf("%d",d); */
    
    /*//n, k : 자연수 N, K 나타냄
    int n, k;
    scanf("%d %d", &n, &k);
    
    //i 변수는 1 ~ n까지 변화하는 값을 가지며,
    //약수를 검사하는 용도로 사용됨
    for(int i=1;i<=n;i++){
        //나머지가 0이라면 i는 n의 약수
        if (n % i == 0) {
            //k 값을 하나씩 감소시키고,
            //만약 k가 0이 되었다면
            //i는 N의 약수 중에서 K번째 작은 수
            //따라서 해당 i 값을 출력하고 반복문 종료
            k--;
            if (k == 0) {
                printf("%d\n", i);
                break;
            }
        }
    }
    
    //반복문이 종료되었는데도 k 값이 0보다 크다면,
    //주어진 N의 약수 개수가 K개보다 적어서
    //K번째 약수가 존재하지 않은 경우이므로 0 출력
    if (k > 0) {
        printf("0\n");
    } */
    
    /*//N, M : 행렬의 크기 나타냄
    int N, M;
    scanf("%d %d", &N, &M);
    
    //N행 M열의 크기를 가지는 두 개의 2차원 배열 선언
    //배열들은 각각 행렬 A, B에 저장
    int A[N][M];
    int B[N][M];
    
    //중첩된 for문을 사용하여 A 행렬의 각 원소 입력
    //각 행과 열에 대해 사용자로부터 정수 값을 입력 받아 A[i][j]에 저장
    for(int i=0; i<N; i++){
        for(int j=0; j<M; j++){
            scanf("%d", &A[i][j]);
        }
    }
     
    //B 행렬의 각 원소 입력
    //각 행과 열에 대해 사용자로부터 정수 값을 입력받아 B[i][j]에 저장
    for(int i=0; i<N; i++){
        for(int j=0; j<M; j++){
            scanf("%d", &B[i][j]);
        }
    }
    
    //중첩 for문 사용하여 A, B 행렬을 더한 결과 출력
    //각 원소의 합인 A[i][j] + B[i][j] 계산
    for(int i=0; i<N; i++){
        for(int j=0; j<M; j++){
            int sum = A[i][j] + B[i][j];
            printf("%d ", sum);
        }
        printf("\n"); //각 행의 원소 출력이 끝나면 줄바꿈하여 다음 행의 원소 출력
    }*/
    
    /*//2차원 배열 arr 선언
    //9 x 9 격자판의 숫자들 저장할 배열
    int arr[9][9];
    int max = 0; //최댓값을 저장하는 변수
    int r = 0, c = 0; //최댓값이 위치한 행과 열 번호를 저장하는 변수
    
    //중첩된 for문을 사용하여 주어진 9x9 격자판의 숫자들을 입력받음
    //각 숫자를 arr[i][j]에 저장하고
    for (int i = 0; i < 9; i++){
        for (int j = 0; j < 9; j++){
            scanf("%d", &arr[i][j]);
            //현재 숫자가 max보다 크다면
            //max 값을 현재 숫자로 갱신하고,
            //동시에 해당 행 번호와 열 번호를 r, c에 저장
            if(max < arr[i][j]){
                max = arr[i][j];
                //행, 열 번호는 1부터 시작하기 때문에 +1를 해준다.
                r = i + 1;
                c = j + 1;

            }
        }
    }
    
    //최댓값과 최댓값이 위치한 행, 열 번호 출력
    printf("%d \n", max);
    printf("%d %d", r, c);
    
    return 0;
}*/

#include <stdio.h>

int main(void) {
    
    //2차원 배열 arr 선언하고 모든 원소 0으로 초기화
    //도화지 위에 붙이는 색종이의 위치를 나타내는 배열
    //'1'로 설정되면 해당 위치에 색종이가 붙은 것으로 간주
    int arr[100][100] = {0,};
    //a, b는 색종이의 왼쪽 위 모서리의 좌표
    //n : 색종이의 수
    //cnt : 검은 영역의 개수를 카운트하는 변수
    int a, b, n;
    int cnt = 0;
    scanf("%d", &n);
    
    //반복문을 사용하여 색종이의 수만큼 색종이의 위치 정보를 입력받고
    //그에 따라 arr 배열을 갱신
    for (int i = 0; i < n; i++){
        scanf ("%d %d", &a, &b);
        for (int j = 0; j < 10; j++){
            for (int k = 0; k < 10; k++){
                //색종이의 왼쪽 위 모시리 좌표(a, b) ~ (a + 9, (b + 9)까지의 범위에
                //해당하는 영역을 1로 채워 넣어 색종이가 있는 영역임을 표히
                arr[a + j][b + k] = 1;
            }
        }
    }

    //중첩 반복문을 사용하여 arr 배열을 순회하며
    //1로 채워진 영역(색종이가 붙은 검은 영역의 개수)를 세어 cnt에 저장
    for (int x = 0; x < 100; x++){
        for (int y = 0; y < 100; y++){
            if (arr[x][y] == 1)
                cnt++;
        }
    }
    //cnt 출력
    printf("%d", cnt);

        return 0;
}
