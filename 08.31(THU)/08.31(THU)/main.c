//
//  main.c
//  08.31(THU)
//
//  Created by 박지현 on 2023/08/31.
//

#include <stdio.h>

int main(void) {
 
    /*//matrix: 격자판을 나타내는 2차원 배열
    //이 배열을 통해 막대를 놓은 위치를 표시하게 된다.
    int matrix[100][100] = {};  //[세로][가로]
    //h: 세로, w: 가로, n: 놓을 수 있는 막대의 개수
    int h,w,n,l,d,x,y;
    scanf("%d %d",&h,&w);
    scanf("%d",&n);
    
    //막대의 개수만큼 반복하면서
    //각 막대의 길이(l), 방향(d), 시작 위치의 좌표(x, y) 입력받기
    for(int i = 1; i <= n; i++){
        scanf("%d %d %d %d",&l,&d,&x,&y);
        //막대의 방향이 가로(0)인 경우,
        //해당 위치부터 오른쪽으로 막대의 길이만큼 이동하면서
        //matrix 배열의 해당 위치를 1로 표시
        if(d == 0){
            for(int j = 0; j<l; j++){
                matrix[x][y+j] = 1;
            }
        }
        //세로(1)인 경우 시작 위치부터
        //아래로 막대의 길이만큼 이동하면서 해당 위치를 1로 표시
        else{
            for(int j = 0; j<l; j++){
                matrix[x+j][y] = 1;
            }
        }
    }
    
    //matrix배열을 순회하면서 각 위치의 값을 출력
    //한 줄(위에서 아래로)씩
    for (int i = 1; i <= h; i++) {
        //한 열(왼쪽에서 오른쪽으로)씩
        for (int j = 1; j <= w; j++) {
            printf("%d ", matrix[i][j]); //값 출력
        }
        printf("\n"); //줄 바꾸기
    }*/
    
    /*//10x10 크기의 미로 상자 구조를 입력받는다.
    //각 위치에 0(갈 수 있는 곳), 1(벽 또는 장애물)
    //2(먹이 위치) 중 하나가 입력된다.
    int matrix[11][11] = {};  //[세로][가로]
    for(int j = 1; j<=10; j++ ){
        for(int i = 1; i<=10; i++ ){
            scanf("%d ",&matrix[j][i]);
        }
    }
    
    //개미의 시작 위치인 (2, 2)를 x, y 변수에 초기화
    int x,y;
    x = 2;
    y = 2;
    
    //개미의 이동을 시뮬레이션한다.
    //미로 상자 내에서 주어진 규칙에 따라 개미가 이동한다.
    while(1){
        //현재 위치가 0이며, 해당 위치를 9로 표시하고
        //오른쪽으로 이동
        if(matrix[x][y] == 0){
            matrix[x][y] = 9; //이동한 경로를 9로 표시
            y ++;
        }
        //현재 위치가 1이면, 벽을 만났으므로
        //왼쪽으로 이동한 후 아래로 이동
        if(matrix[x][y] == 1){
            y --;
            x++;
        }
        
        //현재 위치가 2이면, 먹이를 찾았으므로
        //해당 위치를 9로 표시하고 루프 종료
        if(matrix[x][y] == 2){
            matrix[x][y] = 9; //먹이 위치에 도달하면 9로 표시하고 루프 종료
            break;
        }
        //오른쪽과 아래쪽으로 갈 수 없는 상황이면(벽이 있는 경우)
        //현재 위치를 0로 표시하고 루프 종료
        else if(matrix[x][y+1] == 1 && matrix[x+1][y] == 1){
            if(matrix[x][y] == 0){
                matrix[x][y] = 9;
            }
            break;
        }
    }
    
    //개미가 이동한 경로가 표시된 matrix 배열 출력
    for(int i = 1; i <= 10; i++){
        for(int j =1; j <= 10; j++){
            printf("%d ",matrix[i][j]);
    }
        printf("\n");
    }*/
    
   /* //2차원 배열 선언
    int Arr[101][101] = {}; //[세로][가로]
    //배열의 크기 입력
    int n;
    scanf("%d", &n);
    
    //주어진 규칙에 따라 배열을 채우는 부분
    //x: 배열에 들어갈 숫자를 의미하는 변수
    int x = 1;
    for(int i = 1; i <= n; i++){
        //i가 홀수인 경우, 오름차순으로 배열 채운다.
        //1부터 n까지 반복하면서 Arr[i][j]에
        //x 값을 넣고 x 2 증가시킨다.
        if(i%2 == 1){
            for(int j = 1; j<=n; j++){
                Arr[i][j] = x;
                x++;
            }
        }
        //i가 짝수인 경우, 내림차순으로 배열 채운다.
        //n부터 1까지 반복하면서 Arr[i][j]에
        //x 값을 넣고 x를 1 증가시킨다.
        else{
            for(int j = n; j>=1; j--){
                Arr[i][j] = x;
                x++;
            }
        }
    }
    
    //생성된 배열 출력 부분
    //Arr배열을 순회하며 각 요소를 출력하고,
    //한 행이 끝날 때마다 줄 바꿈하여 각 행을 구분한다.
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n ; j++){
            printf("%d ",Arr[i][j]);
        }
        printf("\n");
    }*/
    
    /*//Arr 배열을 선언한다.
    //입력된 값들을 저장하는 배열
    int Arr[1001] = {};
    //n개의 값을 배열에 입력받아 저장한다.
    int n;
    scanf("%d",&n);
    
    for(int i = 0; i < n; i++){
        scanf("%d",&Arr[i]); //n개의 값 입력받아 배열에 저장
    }
    
    //입력받은 배열에서 두 개씩 묶어서 비교하고,
    //작은 값을 선택하여 출력한다.
    //인덱스 i와 i+1 위치에 있는 값 중에서 작은 값을 출력한다.
    //주의할 점: 반복문의 종료 조건이 n-1까지인데,
    //입력의 크기가 짝수이므로 마지막 두 값을 비교하지 않아도 된다.
    //따라서 반복문은 n-1까지만 반복한다.
    for(int i = 0; i < n-1; i+=2){
        if(Arr[i] > Arr[i+1])
            printf("%d ",Arr[i+1]);
        else
            printf("%d ",Arr[i]);
    }*/
    
    /*//21x21 크기인 배열 선언
    //입력된 격자판 정보를 저장하는 배열
    int Arr[21][21] = {};
    //n: 세로 길이 입력
    int n;
    scanf("%d",&n);
    
    //각 행의 첫 번째 숫자를 입력받아 배열의 해당 위치에 저장
    for(int i = 0; i<n; i++){
        scanf("%d",&Arr[i][0]);
    }
    
    //입력된 첫 번째 숫자들을 바탕으로
    //나머지 숫자들을 계산하여 배열에 저장하는 부분
    //삼각 격자판의 각 행의 첫 번째 숫자를 바탕으로,
    //그 다음 위치의 값을 계산하고 저장하는 부분
    for(int j = 0; j <n; j++){
        for(int k = 0; k <n; k++){
            //계산 방식: 현재 위치의 값에서 바로 이전 위치의 값을 뺀 값
            if(k <= j){
                Arr[j+1][k+1] = Arr[j+1][k]-Arr[j][k];
            }
        }
    }
    
    //생성된 격자판 출력
    //값이 0인 아닌 경우에만 출력하고,
    //각 행의 마지막에는 줄바꿈을 이용하여 줄을 바꾼다.
    for(int i = 0; i<n; i++){
        for(int j = 0; j<n; j++){
            if(Arr[i][j] != 0 )
                printf("%d ",Arr[i][j]);
        }
        printf("\n");
    }*/
    
    /*//Arr배열을 선언하여 마방진을 저장할 준비
    //n: 마방진 크기 결정
    int Arr[50][50] = {};
    int n;
    scanf("%d",&n);
    int center = (n+1)/2; //중앙 열의 위치
    int value = 0; //순차적으로 채워질 값
    
    //i, j: 현재 위치의 행과 열
    int i = 1; //시작 행
    int j = center; //중앙 열
    
    //순차적으로 값을 채우며 마방진 생성
    //배수인 경우와 아닌 경우에 따라
    //행과 열을 증가/감소 시킴
    for(int k = 0; k< n*n; k++){
        Arr[i][j] = ++value; //값을 채우고 증가
        if(value%n == 0)
            i++; //n의 배수인 경우 행만 증가
        else{
            i--;
            j++;
        }
        //행이나 열의 위치가 벗어날 경우,
        //반대쪽 끝으로 넘어가도록 처리
        if(i < 1)
            i = n; //행이 1보다 작으면 마지막 행으로
        if(j > n)
            j = 1; //열이 n보다 크면 첫 열로
        
    }
     
    for(int i = 1; i <= n; i++){
        for(int j = 1; j<= n; j++){
            printf("%d ",Arr[i][j]); //마방진 출력
        }
        printf("\n");
    }*/
    
    /*//101x101 크기 배열 선언
    int Arr[101][101] = {};
    //배열 크기 입력받음
    int n;
    scanf("%d",&n);
    int value = 0; //순차적으로 채워질 값
    
    //중첩 루프를 사용하여 배열의 각 위치에 값을
    //1부터 ~ n*n까지 순차적으로 채움
    for(int i  = 1 ; i <= n; i++){
        for(int j = 1; j<=n; j++){
            Arr[i][j] = ++value;
        }
    }
     
    //테두리 값들의 합을 저장할 변수
    int sum = 0;
    //중첩 루프를 사용하여 배열의 모든 위치를 순회하며,
    //만약 위치가 배열의 테두리에 해당하는 경우
    //해당하는 값을 sum에 더한다
    for(int i = 1; i <= n; i++){
        for(int j = 1; j<= n; j++){
            if(i == 1 || i == n || j == 1 || j == n){
                sum += Arr[i][j]; //테두리 값들으 더하여 합산
            }
        }
    }
    printf("%d",sum); //테두리의 합 출력*/
    
    /*//101x101 크기 배열 선언
    int Arr[101][101] = {};
    //n: 배열 크기, x, y: 시작 위치
    int n,x,y;
    scanf("%d\n%d %d",&n,&x,&y);
    
    //시작 위치에 1을 대입하여 등고선의 기준 값으로 설정
    //value: 등고선 값(현재 값)을 저장
    Arr[x][y] = 1;
    int value = Arr[x][y];
    
    //위로 올라가는 등고선을 생성하는 부분
    //시작 위치에서 위로 올라가면서 값을 증가시키며 등고선 생성
    for(int i = x-1; i >= 1; i-- ){
        Arr[i][y] = ++value; //위로 등고선 생성
    }
    
    //아래로 내려가는 등고선을 생성하는 부분
    //시작 위치에서 아래로 내려가면서 값을 증가시키며 등고선 생성
    value = Arr[x][y]; //value 초기화
    for(int i = x+1; i <= n; i++ ){
        Arr[i][y] = ++value; //아래로 등고선 생성
    }
    
    //좌우로 등고선 생성하는 부분
    //각 행에서 시작 위치에서부터 좌우로 값을 증가시키며 등고선 생성
    for(int i = 1; i <= n; i++){
        value = Arr[i][y];
        for(int j = y-1; j >= 1; j-- ){
            Arr[i][j] = ++value; //왼쪽 등고선 생성
        }
        value = Arr[i][y];
        for(int j = y+1; j <= n; j++ ){
            Arr[i][j] = ++value; //오른쪽 등고선 생성
        }
    }
    
    //생성된 등고선 출력
    for(int i  = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            printf("%d ",Arr[i][j]);
        }
        printf("\n");
    }*/
       
    return 0;
}
    /*1412//Card: 카드의 숫자를 저장할 공간으로 사용
    int Card[50] = {};
    //카드의 전체 장수 입력받기
    int CardNum;
    scanf("%d",&CardNum);
        
    //카드의 숫자의 범위만큼 반복하여
    //순서대로 배열 Card에 저장 -> 초기 카드 묶음의 정보가 구성됨
    for(int i = 0; i<CardNum; i++){
        Card[i] = i+1;
    }
    
    //CardNum-1개의 줄에 걸쳐서
    //빠진 카드 묶음의 카드 숫자를 입력받고,
    //해당 숫자 위치의 Card 배열 값을 0으로 설정하여
    //빠진 카드를 표시한다.
    int LoseCardNum;
    for(int j = 0; j<CardNum - 1; j++){
        scanf("%d",&LoseCardNum);
        Card[LoseCardNum-1] = 0;
    }
    
    //배열 Card를 순회하면서 값이 0이 아닌 경우
    //(빠진 카드가 아닌 경우)에 해당 카드의 숫자 출력
    //이렇게 하면 빠진 카드의 번호가 출력된다.
    for(int k = 0; k<CardNum; k++){
        if(Card[k] != 0){
            printf("%d",Card[k]);
        }
    }*/
    
    /*1425
    //N: 학생 수, C: 한 줄에 앉을 수 있는 자리 수
    int N,C;
    scanf("%d %d",&N,&C);
    
    //Buf: 학생들의 키 정보를 저장할 배열
    int Buf[99] = {};
    //학생들의 키를 입력받아 저장
    for(int i = 0; i < N; i++){
        scanf("%d",&Buf[i]);
    }
    
    //버블 정렬을 사용하여 오름차순으로 정렬
    //이로써 학생들의 키를 작은 순서대로 정렬
    //버블 정렬: 인접한 두 원소를 비교하여 정렬하는 방법
    //배열의 왼쪽부터 시작하여 인접한 두 원소를 비교하고,
    //만약 두원소의 순서가 잘못되 있따면 위치를 교환한다.
    //이 과정을 배열의 끝까지 계속 반복하면서 가장 큰 원소가 배열의
    //맨 뒤로 이동하게 된다.
    int temp;
    for(int i = 0 ; i < N ; i ++) {
        for(int j = 0 ; j < N -i -1 ; j ++) {
            if(Buf[j]>Buf[j+1]) {
                temp = Buf[j];
                Buf[j] = Buf[j+1];
                Buf[j+1] = temp;
            }
        }
    }
    
    //배열을 순회하며 학생들의 키 출력
    //변수 k를 사용하여 한 줄에 출력되는 학생 수를 계산
    int k = 0;
    for(int j = 0; j < N; j++){
        printf("%d ",Buf[j]);
        k++;
        //k와 c가 같다면, 줄바꿈
        //이렇게 하면 주어진 자리 수에 맞게
        //학생들이 앉게 된다.
        if(C == k){
            printf("\n");
            k=0;
        }
    }*/
    
    /*1430*/
    
    

